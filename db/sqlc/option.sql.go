// Code generated by sqlc. DO NOT EDIT.
// source: option.sql

package db

import (
	"context"
)

const createOption = `-- name: CreateOption :one
insert into "option" (
  "question_id",
  "option",
  "is_correct",
  "created_by",
  "created_at",
  "updated_at"
) values (
    $1,
    $2,
    $3,
    $4,
   now(),
   now()
) RETURNING id, question_id, option, is_correct, created_by, created_at, updated_at, deleted_at
`

type CreateOptionParams struct {
	QuestionID int32  `json:"question_id"`
	Option     string `json:"option"`
	IsCorrect  bool   `json:"is_correct"`
	CreatedBy  int32  `json:"created_by"`
}

func (q *Queries) CreateOption(ctx context.Context, arg CreateOptionParams) (Option, error) {
	row := q.db.QueryRowContext(ctx, createOption,
		arg.QuestionID,
		arg.Option,
		arg.IsCorrect,
		arg.CreatedBy,
	)
	var i Option
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.Option,
		&i.IsCorrect,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteOption = `-- name: DeleteOption :exec
update "option" set
  "deleted_at" = now()
where "id" = $1
`

func (q *Queries) DeleteOption(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteOption, id)
	return err
}

const getAllOptions = `-- name: GetAllOptions :many
select id, question_id, option, is_correct, created_by, created_at, updated_at, deleted_at from "option" 
where "deleted_at"
is null
order by "id"
asc limit $1 offset $2
`

type GetAllOptionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllOptions(ctx context.Context, arg GetAllOptionsParams) ([]Option, error) {
	rows, err := q.db.QueryContext(ctx, getAllOptions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Option{}
	for rows.Next() {
		var i Option
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.Option,
			&i.IsCorrect,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptionsByQuestionId = `-- name: GetOptionsByQuestionId :many
select id, question_id, option, is_correct, created_by, created_at, updated_at, deleted_at from "option" 
where "deleted_at"
is null
and "question_id" = $1
order by "id"
asc limit $2 offset $3
`

type GetOptionsByQuestionIdParams struct {
	QuestionID int32 `json:"question_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) GetOptionsByQuestionId(ctx context.Context, arg GetOptionsByQuestionIdParams) ([]Option, error) {
	rows, err := q.db.QueryContext(ctx, getOptionsByQuestionId, arg.QuestionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Option{}
	for rows.Next() {
		var i Option
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.Option,
			&i.IsCorrect,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOption = `-- name: UpdateOption :exec
update "option" set
  "option" = $1,
  "is_correct" = $2,
  "updated_at" = now()
where "id" = $3
`

type UpdateOptionParams struct {
	Option    string `json:"option"`
	IsCorrect bool   `json:"is_correct"`
	ID        int32  `json:"id"`
}

func (q *Queries) UpdateOption(ctx context.Context, arg UpdateOptionParams) error {
	_, err := q.db.ExecContext(ctx, updateOption, arg.Option, arg.IsCorrect, arg.ID)
	return err
}
